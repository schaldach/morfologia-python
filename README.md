# morfologia-python
O código apresenta 2 exemplos de filtragem que podem ser aplicados em imagens, sendo um para retirar o ruído da imagem e o outro para completar a imagem que possui informações incompletas. A imagem "base" que está sendo utilizada é a letra j manuscrita. O primeiro bloco de código importa as bibliotecas necessárias, sendo a opencv-python (cv2), especializada na manipulação e visualização de imagens, e a numpy, que simplifica a codificação com matrizes e vetores no Python. No próximo bloco, são inicializadas as imagens que devem ser previamente carregadas nos arquivos do google colab, e que serão utilizadas para demonstrar os filtros. Ele também salva a altura e largura das imagens através do atributo shape da imagem (no caso, são salvas as 2 dimensões da "matriz" que representa a imagem, e é utilizada só a 1 imagem como referência para as outras, que possui um tamanho de 2680x2000 e isso pode ser verificado escrevendo "print(altura, largura)" no bloco de código), e declarando o kernel que manipulará as imagens (um kernel é uma pequena matriz que funcionará como um filtro para cada pixel disponível da imagem, multiplicando os pixels adjacentes pelo valor correspondente no kernel). No próximo bloco de código são usadas as funções cv2.erode e cv2.dilate para aplicar os filtros de erosão e dilatação nas imagens. Ambos aceitam como parâmetros a imagem que será utilizada, o kernel (geralmente uma matrix 3x3 ou 5x5 ou 7x7) e o número de iterações (quanto maior, mais acentuado o efeito será). O filtro de erosão corresponde a "diminuir" a imagem atual, e ele funcionará comparando para cada pixel todos os pixels adjacentes: Se todos forem igual a 1 (branco), ele continuará branco, mas se somente 1 pixel dentro do kernel não for igual a 1, o valor do pixel central será igual a 0. Assim, ruídos na imagem como os pontos espalhados fora da letra j serão removidos, pois para cada pixel destes pontos, existem pixels adjacentes que não serão iguais a 1 (pixels do fundo), e portanto estes pixels serão iguais a 0 (pretos). A dilatação funcionará de forma contrária: para cada pixel central do kernel, se pelo menos 1 pixel adjacente for igual a 1, ele também será igual a 1. Assim esse filtro realça objetos na imagem (no caso, brancos), e acaba por eliminar a falta de informações para compor o objeto. ELes poderiam ser usados em sequência (erosão -> dilatação) para remover ruídos na imagem, onde a erosão removeria pequenos pontos indesejados e a dilatação garantiria que o objeto continuasse com seu tamanho original. No próximo bloco de código, é exatamente isso que acontece. São declaradas novas imagens que representam 1. a diferença (podemos pensar na subtração) entre uma imagem que sofreu erosão e uma que sofreu dilatação, mostrando somente o contorno do objeto; 2. A erosão seguida pela dilatação, que retira ruídos aleatórias da imagem como já explicado; 3. A dilatação seguida da erosão, que por sua vez irá retirar os ruídos presentes dentro do objeto, e o filtro de erosão garante que ele permaneça no tamanho original. O último bloco de código mostra todas as imagens já trabalhadas durante o código, sendo 1. a imagem original; 2.
